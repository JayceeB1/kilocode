# Context digest for Supervisor UI utils
# Files considered: 2
# Max chars per file: 4000
# Max chars per digest: 160000

===== webview-ui/src/utils/patchBridge.ts =====
import { vscode } from "./vscode"

/**
 * Bridge for reporting patch operations and errors from the UI to the supervisor service
 */

/**
 * Patch execution outcome
 */
export enum PatchOutcome {
	/** Patch was successfully applied */
	SUCCESS = "success",
	/** Patch failed to apply */
	FAILURE = "failure",
	/** Patch was partially applied */
	PARTIAL = "partial",
	/** Patch was skipped */
	SKIPPED = "skipped",
}

/**
 * Patch classification for categorization
 */
export enum PatchClassification {
	/** Bug fix */
	BUGFIX = "bugfix",
	/** New feature */
	FEATURE = "feature",
	/** Refactoring */
	REFACTOR = "refactor",
	/** Documentation */
	DOCS = "docs",
	/** Test */
	TEST = "test",
	/** Configuration */
	CONFIG = "config",
	/** Other */
	OTHER = "other",
}

/**
 * Result of executing a patch operation
 */
export interface PatchResult {
	/** ID of the patch operation */
	opId: string
	/** Outcome of the patch operation */
	outcome: PatchOutcome
	/** Classification of the patch */
	classification: PatchClassification
	/** Hash of the original content */
	originalHash?: string
	/** Hash of the patched content */
	patchedHash?: string
	/** Optional error message if the patch failed */
	error?: string
	/** Optional warnings */
	warnings?: string[]
	/** Line numbers that were modified */
	modifiedLines?: number[]
	/** Execution time in milliseconds */
	executionTimeMs?: number
}

/**
 * Reports an edit error from the UI to the supervisor service.
 *
 * This function sends an error message to the supervisor service using the
 * vscode postMessage infrastructure. The message is sent with type "supervisor:error"
 * and includes the provided payload.
 *
 * @param payload - The error payload to report. Should contain error details
 *                 in a format expected by the supervisor service
 * @throws Error if posting the message fails
 *
 * @example
 * ```typescript
 * try {
 *   // Some operation that might fail
 *   await applyPatch(patchData);
 * } catch (error) {
 *   const errorPayload = createErrorPayload(error, { operation: 'applyPatch' });
 *   reportEditError(errorPayload);
 * }
 * ```
 */
export function reportEditError(payload: any): void {
	try {
		// Type assertion to bypass TypeScript checking for new message types
		;(vscode.postMessage as any)({
			type: "supervisor:error",
			payload,
		})
	} catch (error) {
		console.error("Failed to report edit error:", error)
		throw new Error(`Failed to report edit error: ${error instanceof Error ? error.message : String(error)}`)
	}
}

/**
 * Reports a patch result from the UI to the supervisor service.
 *
 * This function sends a patch result message to the supervisor service using the
 * vscode postMessage infrastructure. The message is sent with type "supervisor:result"
 * and includes the provided patch result data.
 *
 * @param result - The patch result to report. Should contain operation outcome,
 *                 classification, and other relevant metadata
 * @throws Error if posting the message fails
 *
 * @example
 * ```typescript
 * const result: PatchResult = {
 *   opId: 'patch-123',
 *   outcome: PatchOutcome.SUCCESS,
 *   classification: PatchClassification.BUGFIX,
 *   executionTimeMs: 150
 * };
 *
 * reportPatchResult(result);
 * ```
 */
export function reportPatchResult(result: PatchResult): void {
	try {
		// Type assertion to bypass TypeScript checking for new message types
		;(vscode.postMessage as any)({
			type: "supervisor:result",
			payload: result,
		})
	} catch (error) {
		console.error("Failed to report patch result:", error)
		throw new Error(`Failed to report patch result: ${error instanceof Error ? error.message : String(error)}`)
	}
}

/**
 * Creates a standardized error payload for the supervisor service.
 *
 * This helper function formats an error object into a standardized payload
 * that can be sent to the supervisor service. It includes the error message,
 * stack trace, optional context, and a timestamp.
 *
 * @param error - The error o
…[truncated]

# note: truncated to stay within per-file budget


===== webview-ui/src/utils/__tests__/patchBridge.spec.ts =====
import { describe, test, expect, vi, beforeEach } from "vitest"
import { vscode } from "../vscode"
import {
	reportEditError,
	reportPatchResult,
	createErrorPayload,
	createPatchResultPayload,
	PatchOutcome,
	PatchClassification,
	type PatchResult,
} from "../patchBridge"

// Mock vscode module
vi.mock("../vscode")

describe("patchBridge", () => {
	beforeEach(() => {
		vi.clearAllMocks()
		// Reset mock implementation to default (no error)
		vi.mocked(vscode).postMessage.mockImplementation(() => {})
	})

	describe("reportEditError", () => {
		test("should post error message with correct type and payload", () => {
			const errorPayload = { message: "Test error", code: 500 }

			reportEditError(errorPayload)

			expect(vi.mocked(vscode).postMessage).toHaveBeenCalledWith({
				type: "supervisor:error",
				payload: errorPayload,
			})
		})

		test("should handle postMessage errors", () => {
			const errorMessage = "PostMessage failed"
			vi.mocked(vscode).postMessage.mockImplementation(() => {
				throw new Error(errorMessage)
			})

			expect(() => reportEditError({ message: "Test" })).toThrow(`Failed to report edit error: ${errorMessage}`)
		})
	})

	describe("reportPatchResult", () => {
		test("should post patch result with correct type and payload", () => {
			const result: PatchResult = {
				opId: "test-op-123",
				outcome: PatchOutcome.SUCCESS,
				classification: PatchClassification.BUGFIX,
				executionTimeMs: 150,
			}

			reportPatchResult(result)

			expect(vi.mocked(vscode).postMessage).toHaveBeenCalledWith({
				type: "supervisor:result",
				payload: result,
			})
		})

		test("should handle postMessage errors", () => {
			const errorMessage = "PostMessage failed"
			vi.mocked(vscode).postMessage.mockImplementation(() => {
				throw new Error(errorMessage)
			})

			const result: PatchResult = {
				opId: "test-op-123",
				outcome: PatchOutcome.FAILURE,
				classification: PatchClassification.OTHER,
			}

			expect(() => reportPatchResult(result)).toThrow(`Failed to report patch result: ${errorMessage}`)
		})
	})

	describe("createErrorPayload", () => {
		test("should create error payload with message, stack, and timestamp", () => {
			const error = new Error("Test error message")
			error.stack = "Error: Test error message\n    at test.js:1:1"

			const payload = createErrorPayload(error)

			expect(payload).toEqual({
				message: "Test error message",
				stack: "Error: Test error message\n    at test.js:1:1",
				context: {},
				timestamp: expect.any(String),
			})

			// Verify timestamp is a valid ISO string
			expect(new Date(payload.timestamp)).toBeInstanceOf(Date)
		})

		test("should include context when provided", () => {
			const error = new Error("Test error")
			const context = { operation: "test", filePath: "/test/file.ts" }

			const payload = createErrorPayload(error, context)

			expect(payload.context).toEqual(context)
		})

		test("should handle errors without stack trace", () => {
			const error = new Error("Test error")
			delete error.stack

			const payload = createErrorPayload(error)

			expect(payload.message).toBe("Test error")
			expect(payload.stack).toBeUndefined()
		})
	})

	describe("createPatchResultPayload", () => {
		test("should create patch result payload with result data and timestamp", () => {
			const result: PatchResult = {
				opId: "test-op-456",
				outcome: PatchOutcome.SUCCESS,
				classification: PatchClassification.FEATURE,
				modifiedLines: [10, 11, 12],
				executionTimeMs: 200,
			}

			const payload = createPatchResultPayload(result)

			expect(payload).toEqual({
				...result,
				context: {},
				timestamp: expect.any(String),
			})

			// Verify timestamp is a valid ISO string
			expect(new Date(payload.timestamp)).toBeInstanceOf(Date)
		})

		test("should include context when provided", () => {
			const result: PatchResult = {
				opId: "test-op-789",
				outcome: PatchOutcome.PARTIAL,
				classification: PatchClassification.REFACTOR,
			}
			const contex
…[truncated]

# note: truncated to stay within per-file budget
