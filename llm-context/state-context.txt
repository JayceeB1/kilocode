# Context digest for Supervisor UI state
# Files considered: 4
# Max chars per file: 4000
# Max chars per digest: 160000

===== webview-ui/src/state/supervisorSlice.ts =====
import React, { createContext, useContext, useEffect, useState } from "react"
import { sendWithCompat } from "../utils/vscode"

export type SupervisorConfig = {
	version: 1
	enabled: boolean
	autoLaunch: boolean
	bind: string // "127.0.0.1" or LAN (10.0.4.x)
	port: number // 9600..9699 (default 9611)
	provider: "ollama" | "llama.cpp"
	endpoint: string // e.g. http://127.0.0.1:11434
	model: string
	max_tokens: number
	temperature: number
	allowLAN: boolean
	allowedLANs: string[]
	redactLog: boolean
}

type Ctx = {
	enabled: boolean
	setEnabled: (v: boolean) => void
}

const SupervisorCtx = createContext<Ctx>({ enabled: false, setEnabled: () => {} })

export const SupervisorProvider: React.FC<{ children: React.ReactNode }> = ({ children }) => {
	const [enabled, setEnabled] = useState(false)

	// Hydrate depuis la config (IPC)
	useEffect(() => {
		;(async () => {
			try {
				const cfg = await sendWithCompat("supervisor:get")
				if (cfg && typeof cfg.enabled === "boolean") setEnabled(!!cfg.enabled)
			} catch {
				// Ignore errors
			}
		})()
	}, [])

	// Raccourci clavier Ctrl+Alt+L
	useEffect(() => {
		const onKey = (e: KeyboardEvent) => {
			const k = e.key?.toLowerCase()
			if (e.ctrlKey && e.altKey && k === "l") setEnabled((v) => !v)
		}
		window.addEventListener("keydown", onKey)
		return () => window.removeEventListener("keydown", onKey)
	}, [])

	return React.createElement(SupervisorCtx.Provider, { value: { enabled, setEnabled } }, children)
}

export const useSupervisor = () => useContext(SupervisorCtx)


===== webview-ui/src/state/__tests__/supervisorSlice.spec.tsx =====
import React from "react"
import { render, screen, waitFor } from "@testing-library/react"
import userEvent from "@testing-library/user-event"
import { vi } from "vitest"
import { SupervisorProvider, useSupervisor } from "../supervisorSlice"
import { sendWithCompat } from "../../utils/vscode"

// Mock vscode utility
vi.mock("../../utils/vscode", () => ({
	sendWithCompat: vi.fn(),
}))

const mockSendWithCompat = vi.mocked(sendWithCompat)

// Test component to access the context
function TestComponent() {
	const { enabled, setEnabled } = useSupervisor()
	return (
		<div>
			<div data-testid="enabled-state">{enabled.toString()}</div>
			<button onClick={() => setEnabled(!enabled)}>Toggle</button>
		</div>
	)
}

describe("supervisorSlice", () => {
	const defaultConfig = {
		version: 1,
		enabled: false,
		autoLaunch: false,
		bind: "127.0.0.1",
		port: 9611,
		provider: "ollama" as const,
		endpoint: "http://127.0.0.1:11434",
		model: "llama3.1:8b-instruct-q4",
		max_tokens: 768,
		temperature: 0.2,
		allowLAN: false,
		allowedLANs: ["10.0.4.0/24"],
		redactLog: true,
	}

	beforeEach(() => {
		vi.clearAllMocks()
		mockSendWithCompat.mockResolvedValue(defaultConfig)
	})

	it("provides default enabled state as false", () => {
		render(
			<SupervisorProvider>
				<TestComponent />
			</SupervisorProvider>,
		)

		expect(screen.getByTestId("enabled-state")).toHaveTextContent("false")
	})

	it("loads configuration from IPC on mount", async () => {
		render(
			<SupervisorProvider>
				<TestComponent />
			</SupervisorProvider>,
		)

		// Should render with default state
		expect(screen.getByTestId("enabled-state")).toHaveTextContent("false")
	})

	it("toggles enabled state when setEnabled is called", async () => {
		const user = userEvent.setup()

		render(
			<SupervisorProvider>
				<TestComponent />
			</SupervisorProvider>,
		)

		// Initial state should be false
		expect(screen.getByTestId("enabled-state")).toHaveTextContent("false")

		// Click the toggle button
		await user.click(screen.getByText("Toggle"))

		// State should now be true
		expect(screen.getByTestId("enabled-state")).toHaveTextContent("true")

		// Click again
		await user.click(screen.getByText("Toggle"))

		// State should be false again
		expect(screen.getByTestId("enabled-state")).toHaveTextContent("false")
	})

	it("handles keyboard shortcut Ctrl+Alt+L", async () => {
		render(
			<SupervisorProvider>
				<TestComponent />
			</SupervisorProvider>,
		)

		await waitFor(() => {
			expect(mockSendWithCompat).toHaveBeenCalled()
		})

		// Initial state should be false
		expect(screen.getByTestId("enabled-state")).toHaveTextContent("false")

		// Simulate Ctrl+Alt+L keypress
		const event = new KeyboardEvent("keydown", {
			key: "l",
			ctrlKey: true,
			altKey: true,
		})
		window.dispatchEvent(event)

		// State should be toggled to true
		await waitFor(
			() => {
				expect(screen.getByTestId("enabled-state")).toHaveTextContent("true")
			},
			{ timeout: 1000 },
		)

		// Simulate Ctrl+Alt+L again
		window.dispatchEvent(event)

		// State should be toggled back to false
		await waitFor(
			() => {
				expect(screen.getByTestId("enabled-state")).toHaveTextContent("false")
			},
			{ timeout: 1000 },
		)
	})

	it("ignores other key combinations", async () => {
		render(
			<SupervisorProvider>
				<TestComponent />
			</SupervisorProvider>,
		)

		// Initial state should be false
		expect(screen.getByTestId("enabled-state")).toHaveTextContent("false")

		// Simulate Ctrl+L (without Alt)
		const ctrlLEvent = new KeyboardEvent("keydown", {
			key: "l",
			ctrlKey: true,
			altKey: false,
		})
		window.dispatchEvent(ctrlLEvent)

		// State should remain false
		expect(screen.getByTestId("enabled-state")).toHaveTextContent("false")

		// Simulate Alt+L (without Ctrl)
		const altLEvent = new KeyboardEvent("keydown", {
			key: "l",
			ctrlKey: false,
			altKey: true,
		})
		window.dispatchEvent(altLEvent)

		// State should remain false
		expect(screen.getByTestI
…[truncated]

# note: truncated to stay within per-file budget


===== webview-ui/src/state/patcherSlice.ts =====
import React, { createContext, useContext, useEffect, useState } from "react"

/**
 * Patcher event classification types
 */
export type PatcherClassification = "applied" | "anchor_mismatch" | "lint_error" | "type_error" | "noop" | "unknown"

/**
 * Interface for a patcher event
 */
export interface PatcherEvent {
	/** ID of the message that triggered the patcher event */
	messageId: string
	/** Classification of the patcher result */
	classification: PatcherClassification
	/** Optional file path where the patcher was applied */
	file?: string
	/** Optional error description if the patcher failed */
	error?: string
	/** Optional suggested plan for remediation */
	suggestedPlan?: any
	/** Timestamp when the event was received */
	ts: number
}

/**
 * Interface for the patcher events state
 */
export interface PatcherState {
	/** Map of patcher events indexed by messageId */
	events: Record<string, PatcherEvent>
}

/**
 * Context type for the patcher chat provider
 */
type PatcherContextType = {
	/** Current patcher state */
	state: PatcherState
	/** Function to add or update a patcher event */
	addOrUpdateEvent: (event: PatcherEvent) => void
	/** Function to clear all patcher events */
	clearEvents: () => void
	/** Function to get a specific patcher event by messageId */
	getEvent: (messageId: string) => PatcherEvent | undefined
}

/**
 * Default context value
 */
const PatcherContext = createContext<PatcherContextType>({
	state: { events: {} },
	addOrUpdateEvent: () => {},
	clearEvents: () => {},
	getEvent: () => undefined,
})

/**
 * Provider component for patcher event state management
 *
 * This component listens for "supervisor:patcherEvent" messages from the window
 * and maintains an in-memory map of events by messageId.
 *
 * @param children - React children components
 *
 * @example
 * ```tsx
 * <PatcherChatProvider>
 *   <App />
 * </PatcherChatProvider>
 * ```
 */
export const PatcherChatProvider: React.FC<{ children: React.ReactNode }> = ({ children }) => {
	const [state, setState] = useState<PatcherState>({ events: {} })

	/**
	 * Add or update a patcher event in the state
	 *
	 * @param event - The patcher event to add or update
	 */
	const addOrUpdateEvent = (event: PatcherEvent) => {
		setState((prevState) => ({
			events: {
				...prevState.events,
				[event.messageId]: event,
			},
		}))
	}

	/**
	 * Clear all patcher events from the state
	 */
	const clearEvents = () => {
		setState({ events: {} })
	}

	/**
	 * Get a specific patcher event by messageId
	 *
	 * @param messageId - The message ID to look up
	 * @returns The patcher event if found, undefined otherwise
	 */
	const getEvent = (messageId: string): PatcherEvent | undefined => {
		return state.events[messageId]
	}

	/**
	 * Effect to listen for supervisor:patcherEvent messages
	 */
	useEffect(() => {
		const handleMessage = (event: MessageEvent) => {
			const message = event.data

			// Check if this is a supervisor:patcherEvent message
			if (message?.type === "supervisor:patcherEvent") {
				try {
					// Validate required fields
					if (!message.messageId || !message.classification) {
						throw new Error("Missing required fields: messageId and classification")
					}

					const patcherEvent: PatcherEvent = {
						messageId: message.messageId,
						classification: message.classification,
						file: message.file,
						error: message.error,
						suggestedPlan: message.suggestedPlan,
						ts: Date.now(),
					}

					addOrUpdateEvent(patcherEvent)
				} catch (error) {
					console.error("Failed to process supervisor:patcherEvent message:", error)
				}
			}
		}

		// Add event listener for window messages
		window.addEventListener("message", handleMessage)

		// Clean up event listener on unmount
		return () => {
			window.removeEventListener("message", handleMessage)
		}
	}, [])

	const contextValue: PatcherContextType = {
		state,
		addOrUpdateEvent,
		clearEvents,
		getEvent,
	}

	return React.createElement(PatcherContext.Provider, { va
…[truncated]

# note: truncated to stay within per-file budget


===== webview-ui/src/state/__tests__/patcherSlice.spec.tsx =====
import React from "react"
import { render, act, fireEvent } from "@testing-library/react"
import { describe, it, expect, beforeEach, vi } from "vitest"
import {
	PatcherChatProvider,
	usePatcherChat,
	createPatcherEvent,
	isSuccessfulEvent,
	isErrorEvent,
	type PatcherEvent,
	type PatcherClassification,
} from "../patcherSlice"

// Mock console.error to avoid test output noise
vi.mock("../../../utils/vscode", () => ({
	vscode: {
		postMessage: vi.fn(),
	},
}))

describe("patcherSlice", () => {
	let TestComponent: React.FC<{ onStateUpdate?: (state: any) => void }>

	beforeEach(() => {
		// Reset all mocks before each test
		vi.clearAllMocks()

		// Create a test component that uses the hook
		TestComponent = ({ onStateUpdate }) => {
			// eslint-disable-next-line @typescript-eslint/no-unused-vars
			const { state, addOrUpdateEvent, clearEvents, getEvent } = usePatcherChat()

			// Call the callback with the current state for testing
			React.useEffect(() => {
				onStateUpdate?.(state)
			}, [state, onStateUpdate])

			return <div data-testid="test-component">Test Component</div>
		}
	})

	describe("PatcherChatProvider", () => {
		it("should provide initial state with empty events map", () => {
			let capturedState: any

			render(
				<PatcherChatProvider>
					<TestComponent
						onStateUpdate={(state) => {
							capturedState = state
						}}
					/>
				</PatcherChatProvider>,
			)

			expect(capturedState).toEqual({ events: {} })
		})

		it("should handle supervisor:patcherEvent messages", () => {
			let capturedState: any

			render(
				<PatcherChatProvider>
					<TestComponent
						onStateUpdate={(state) => {
							capturedState = state
						}}
					/>
				</PatcherChatProvider>,
			)

			// Simulate a supervisor:patcherEvent message
			const patcherMessage = {
				type: "supervisor:patcherEvent",
				messageId: "test-message-123",
				classification: "applied" as PatcherClassification,
				file: "/path/to/test.ts",
				error: undefined,
				suggestedPlan: undefined,
			}

			act(() => {
				fireEvent(window, new MessageEvent("message", { data: patcherMessage }))
			})

			expect(capturedState.events["test-message-123"]).toBeDefined()
			expect(capturedState.events["test-message-123"].messageId).toBe("test-message-123")
			expect(capturedState.events["test-message-123"].classification).toBe("applied")
			expect(capturedState.events["test-message-123"].file).toBe("/path/to/test.ts")
			expect(capturedState.events["test-message-123"].ts).toBeTypeOf("number")
		})

		it("should handle supervisor:patcherEvent messages with error", () => {
			let capturedState: any

			render(
				<PatcherChatProvider>
					<TestComponent
						onStateUpdate={(state) => {
							capturedState = state
						}}
					/>
				</PatcherChatProvider>,
			)

			// Simulate a supervisor:patcherEvent message with error
			const patcherMessage = {
				type: "supervisor:patcherEvent",
				messageId: "test-message-456",
				classification: "anchor_mismatch" as PatcherClassification,
				file: "/path/to/test.ts",
				error: "Anchor mismatch error",
				suggestedPlan: { action: "retry" },
			}

			act(() => {
				fireEvent(window, new MessageEvent("message", { data: patcherMessage }))
			})

			expect(capturedState.events["test-message-456"]).toBeDefined()
			expect(capturedState.events["test-message-456"].error).toBe("Anchor mismatch error")
			expect(capturedState.events["test-message-456"].suggestedPlan).toEqual({ action: "retry" })
		})

		it("should ignore non-supervisor:patcherEvent messages", () => {
			let capturedState: any

			render(
				<PatcherChatProvider>
					<TestComponent
						onStateUpdate={(state) => {
							capturedState = state
						}}
					/>
				</PatcherChatProvider>,
			)

			// Simulate a different message type
			const otherMessage = {
				type: "other:message",
				data: "should be ignored",
			}

			act(() => {
				fireEvent(window, new MessageEvent("message", { data: otherMessage }))
			})

			// State should remain 
…[truncated]

# note: truncated to stay within per-file budget
